参看书籍:
<深入理解linux内核>
https://blog.csdn.net/gatieme/article/details/51456569


主要内容：
1.进程与线程的基本概念
    1）.程序：程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。
    2）.进程：进程是处于执行期的程序以及它所管理的资源（如打开的文件、挂起的信号、进程状态、地址空间等等）的总称。它是一个动态的概念，是一个活动的实体。进程是资源拥有的基本单位。
    3）.线程：线程是独立调度的基本单位。
    4）.线程和进程的区别：
        a).子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下。
        b).进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
        c).线程上下文切换比进程上下文切换要快得多
    5）.内核线程：内核线程(kernel Threads)就是内核的分身，一个分身可以处理一件特定事情。这在处理异步事件如异步IO时特别有用。内核线程的使用是廉价的，唯一使用的资源就是内核栈和上下文切换时保存寄存器的空间。支持多线程的内核叫做多线程内核(Multi-Threads kernel )。其拥有：进程描述符、PID、进程正文段、核心堆栈。
        a).创建：古老的接口 kernel_thread和daemonize；现在的方法kthead_create(需要在父进程中通过调用wake_up_process函数来启动该线程)和kthread_run(创建并启动线程)。
        b).退出:kthread_stop
        c).内核机制的变迁：kernel_thread接口(arch_kernel_thread)——>Workqueue机制——>2号进程kthreadd管理(_do_fork实现，早期内核中是do_fork).
    6）.用户线程：用户线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁全又库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。用户进程拥有：进程描述符、PID、进程正文段、核心堆栈 、同父进程共享用户空间的数据段和堆栈。
    7）.轻量级进程：轻量级进程(LWP)是建立在内核之上并由内核级线程支持的用户线程，它是内级核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。(在一些系统中，LWP就是用户线程，但是在一些系统中则不是)。


2.进程的状态及模型
    1）.二态模型：运行态与非运行态的转换
    2）.五态模型：新建态，就绪态，运行态，阻塞态，退出态。可能存在的转换过程有：空——>新建态;新建态——>就绪态;就绪态——>运行态;运行态——>退出态;运行态——>就绪态;运行态——>阻塞态;阻塞态——>就绪态;就绪态——>退出态；阻塞态——>退出。
    3）.七态模型：新建态，就绪态，运行态，阻塞态，阻塞挂起态，就绪挂起态，退出态。可能存在的转换过程有：等待态—→挂起等待态；挂起等待态—→挂起就绪态；挂起就绪态—→就绪态；就绪态—→挂起就绪态；挂起等待态—→等待态；运行态—→挂起就绪态；新建态—→挂起就绪态；
    4）.LINUX状态模型：运行态，可中断等待态，不可中断等待态，暂停态，跟踪态，僵死态，退出态，TASK_KILLABLE态

3.线程的实现
    1）.用户级线程(User Level Thread)：有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在. 应用程序可以通过使用线程库设计成多线程程序(多个用户线程对一内核线程模型).
    2）.内核级线程(Kemel Level Thread):内核线程建立和销毁都是由操作系统负责、通过系统调用完成的。在内核的支持下运行，无论是用户进程的线程，或者是系统进程的线程，他们的创建、撤销、切换都是依靠内核实现的(一个用户线程对一内核线程模型)。
    3）.混合型模型:线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行. 一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上(多对多模型)。
    4）.Linux的线程模型：通过用户线程+LWP来实现线程-进程1对1模型。即一个用户线程对应一个轻量级进程，而一个轻量级进程对应一个特定的内核线程。只有此时，LWP才是等效于用户线程。 同时，linux下将多个用户线程（也是LWP）组成为一个线程池，该线程池中不同的LWP有不同的pid，而有相同的tgid。对于内核来说，通过管理每一个LWP的pid来实现对每一个LWP的管理，而对于用户系统而言，其可见只是gtid。
    注意：混合型线程模型通常也是通过用户线程+LWP来实现，通常为多个用户线程对应一个轻量级进程，而一个轻量级进程对应一个特定的内核线程。在只有此时，LWP才是不等效于用户线程。
     

4.LINUX进程的描述（进程描述符，进程控制块）
    1）.进程影像及位置
    2）.进程标识信息：
        a).描述：标识符(pid和tgid),task_struct结构的地址。
        b).进程ID号的管理：......
    3）.进程控制信息：
        调度与状态：进程状态state;进程标记flags;进程优先级prio等；进程调度策略policy；进程调度类sched_class；等
        进程通信：信号处理signal等；进程通信sysvsem；相关锁alloc_lock；等
        存储信息：内存描述符mm；运行时所使用的内存描述符active_mm；缺页统计；等
        资源限制：文件系统信息fs；文件信息files；等
        组织结构：构建进程链表tasks；表示进程亲属关系的成员；等;
        其他：ptrace系统调用;Performance Event；判断标志；时间；等
    4）.进程状态信息(处理器状态信息)：
        a).描述：PC；控制状态寄存器器；FPU使用计数fpu_counter；内核栈指针stack(用户程序栈指针在mm)；等        
        b).内核栈数据结构：内核将内核态的堆栈stack[2048]和线程描述符thread_info组成一个联合体thread_union，放在8k的空间，同事，让这8K空间占据连续的两个页框并让第一个页框的起始地址是2的13次方的倍数。这样做的好处为：内核可以通过sp指针得到CPU当前运行内核线程的堆栈地址，通过堆栈地址结合thread_union的存放规则可以得到thread_info的地址(屏蔽sp的低13位)，在通过thread_info中task变量就可以知道当前进程描述符task_struct的地址，进而得到pid。

5.LINUX进程控制
    1）.切换:......
    2）.创建:
        a).创建接口:
            fork()：fork创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容task_struct内容。由于这样大批量复制导致效率太低，故linux中采用写时复制技术来改善这个问题。
            vfork()：vfork创建的子进程与父进程共享数据段,而且由vfork()创建的子进程将先于父进程运行。创建的子进程不要使用return，而是使用exit或者_exit来代替
            clone()：Linux上创建线程一般使用的是pthread库 实际上linux也给我们提供了创建线程的系统调用，就是clone。
        b).实现:上述几个系统调用都是通过_do_fork(老版中使用的do_fork实现的）。
            _do_fork(版本4.2)的实现流程：
                使用copy_process()复制进程描述符——>得到新创建的进程的pid信息——>如果调用的 vfork()方法，初始化 vfork 完成处理信息——>通过wake_up_new_task将子进程加入到调度器中，为其分配 CPU，准备执行——>如果是 vfork，将父进程加入至等待队列，等待子进程完成；
            其中dup_task_struct(版本4.2)的实现流程()：
                调用 dup_task_struct 复制当前的 task_struct——>检查进程数是否超过限制——>初始化自旋锁、挂起信号、CPU 定时器等——>调用 sched_fork 初始化进程数据结构，并把进程状态设置为 TASK_RUNNING——>复制所有进程信息，包括文件系统、信号处理函数、信号、内存管理等——>调用 copy_thread_tls(该函数依赖与体系结构) 初始化子进程内核栈——>为新进程分配并设置新的 pid——>调用fork的进程为其父进程；
            其中copy_process(版本4.2)的实现流程()：
                调用alloc_task_struct_node分配一个 task_struct 节点——>调用alloc_thread_info_node分配一个 thread_info 节点——>将栈底的值赋给新节点的栈；
            其中sched_fork(版本4.2)的实现流程()：
                将子进程状态设置为 TASK_RUNNING——> 分配 CPU；
            其中copy_thread_tls(版本4.2，32位架构)的实现流程()：
                获取寄存器的信息——>内核线程的设置——> 将当前寄存器信息复制给子进程——> 子进程 eax 置 0，因此fork 在子进程返回0 ——>子进程ip 设置为ret_from_fork，因此子进程从ret_from_fork开始执行  ——>为进程设置一个新的TLS
            其中wake_up_new_task(版本4.2)的实现流程()：
                调整父子进程的调度参数——>设置父子进程的页表                
    3）.加载:
        a).加载接口:系统调用接口（execve），C库接口（execl，execle，execlp，execv，execvp）;
        b).可执行文件及其表示：Linux下标准的可执行文件格式是ELF.并且使用linux_bin_prm结构来表示保存可执行程序的信息, 比如可执行文件的路径, 运行的参数和环境变量等信息。还使用linux_binfmt描述各种可执行程序的加载和执行函数
        c).实现:上述中C库接口是通过调用execve实现，而execve的系统调用则是通过do_execve实现的，do_execve实现流程为：
            调用do_execve()打开目标映像文件，并从目标文件的头部读入若干字节——> 调用do_execveat_common (早期的程序中没有该函数封装)——>调用search_binary_handler()，搜索Linux支持的可执行文件类型队列，让各种可执行程序的处理程序前来认领和处理——>如果类型匹配，则调用load_binary函数指针所指向的处理函数来处理目标映像文件

    4).等待与退出：
        a)退出方式：正常退出(return，c库中的exit和_Exit,系统调用_exit());异常退出(调用abort,调用信号终止)
        b)等待与退出接口：等待接口(wait()，waitid（）);退出接口(exit()，exit_group());
        c)实现：等待接口最终都是调用do_wait()接口，退出接口最终都是调用do_exit()接口(exit_group设置current->signal->group_exit_code和调用zap_other_threads()函数杀死current线程组中的其它进程)。
            do_wait实现流程为：......
            do_exit实现流程：
                触发task_exit_nb通知链实例的处理函数——>检查进程的blk_plug是否为空——>OOPS消息——>设定进程可以使用的虚拟地址的上限检查进病——>设置进程程PF_EXITING——>内存屏障——>同步进程的mm的rss_stat——>获取current->mm-> rss_stat.count[member]计数——>清除定时器——>收集进程会计信息——>审计——>释放进程占用的资源——>检查有多少未使用的进程内核栈——>调度其它进程

    5）.几个主要进程的建立过程：
        idle进程(PID = 0)：其前身是系统创建的第一个进程，也是唯一一个没有通过fork或者kernel_thread产生的进程。系统启动在startup_32(...kernel/head.S)中为该进程设置了执行环境(通过init_task，init_mm静态建立)，然后该文件又跳转到start_kernel；在start_kernel中处理包括初始化页表，初始化中断向量表，初始化系统时间等初始化工作，最后跳转到rest_init()函数；在rest_init()函数中创建了init进程和kthreadd进程，并将该进程演化为0号进程，并且运行在内核态。
        init进程(PID = 1)：由0进程创建，完成系统的初始化. 是系统中所有其它用户进程的祖先进程。Linux中的所有进程都是有init进程创建并运行的。首先Linux内核启动，然后在用户空间中启动init进程，再启动其他系统进程。在系统启动完成完成后，init将变为守护进程监视系统其他进程。 
        kthreadd进程(PID = 2)：它的任务就是管理和调度其他内核线程kernel_thread, 会循环执行一个kthread的函数，该函数的作用就是运行kthread_create_list全局链表中维护的kthread, 当我们调用kernel_thread创建的内核线程会被加入到此链表中，因此所有的内核线程都是直接或者间接的以kthreadd为父进程 
    注意：写时复制技术


    
    