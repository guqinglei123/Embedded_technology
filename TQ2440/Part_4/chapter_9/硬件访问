参看书籍:
<Linux设备驱动开发详解——基于ＬINUX 4.0 内核>
<Linux设备驱动程序>
<深入理解linux内核>


主要内容：
１.ＩＯ端口与ＩＯ内存的区别
    设备通常会提供一组寄存器来控制设备。若这些寄存器位于ＩＯ空间(独立编址)，则称其为ＩＯ端口，若位于内存空间(统一编址)，则称其为ＩＯ内存。s3c24x0处理器是使用I/O内存。
    注意：
        １)操作内存中的ＩＯ寄存器与内存操作有少许差异为：IO寄存器有边际效应，而内存没有;
        2)边际效应(side effect )：访问I/O寄存器时，不仅仅会像访问普通内存一样影响存储单元的值，更重要的是它可能改变CPU的I/O端口电平、输出时序或CPU对I/O端口电平的反应等等，从而实现CPU的控制功能。CPU在电路中的意义就是实现其side effect 。
        3)导致问题：为了提高内存的访问速度，编译器会对程序进行优化，同时使用高速缓存保存数值和重新编排读/写指令顺序。但对I/O 寄存器操作来说，这些优化可能造成致命错误。
        4)解决方法：关闭硬件缓存，设置内存屏障(barrier(),mb());　
２.访问ＩＯ端口
    驱动程序访问：分配ＩＯ端口(request_region)——>操作ＩＯ端口(8bit inb,outb;16bit inw,outw;32bit inl,outl;一串字节 insb,outsb;一串字 insw,outsw;一串字 insl,outsl;)——>归还ＩＯ端口(release_region());
    用户空间访问:编译时需要带－Ｏ选项——>在root权限下，运行ioperm/iopl或者通过dev/port来获得端口的操作权限——>使用上述操作ＩＯ端口函数。
    将ＩO端口映射为ＩＯ内存：ioport_map
    注意：
        1)对串的进行操作时，要注意字节序的问题。
        2)为了匹配低速外设的速度，有时若 I/O 指令后面还紧跟着另一个类似的I/O指令，就必须在 I/O 指令后面插入一个小延时。在这种情况下，可以使用暂停式的I/O函数代替通常的I/O函数，它们的名字以 _p 结尾。
        3)端口映射到内存，支持所有函数。串操作 用C语言实现。端口是 unsigned int 类型。
３.访问ＩＯ内存
    驱动程序访问：分配ＩＯ内存(request_mem_region)——>地址映射(ioremap())——>操作ＩＯ内存(8,16,32bit的读写分别为readb,writeb,readw,writew,readl,writel;此外,如果有_relaxed,则代表有内存屏障,此外，还有相应的接口ioread8/iowrite8等)——>解除映射(iounmap())——>归还ＩＯ端口(release_mem_region())


    用户空间访问：在用户空间访问设备地址是通过驱动中的mmap或者nopage方法进行访问，如果该驱动没有提供该方法则无法访问。方法有：
        1)通过系统调用mmap()分配了虚拟地址(得到vma)——>根据文件标识符会调用驱动对应的mmap()方法(怎么实现的？是发生缺页异常时调用吗？)——>访问通过remap_pfn_range分配页表项(实现物理地址和虚拟地址的对应。这里会分配页框是什么情况？)——>为VAM添加相应操作
        ２)线性区VMA的接口函数falut()/nopage()映射，当发生缺页异常是会调用。过程为：找到缺页的虚拟地址所在VMA——>分配页目录项，页表——>如果页表对应的物理页不存在这调用fault方法——>将物理地址填到页表中(如果需要使用函数mremap()对虚拟线性区进行缩小和扩大，则必须要有falut()/nopage()的支持)。
        
        
        

    ＩＯ内存的静态映射：map_desc()
    直接内存访问(DMA)：
    直接ＩＯ访问：
        异步ＩＯ访问：
    注意：
        1)ioremap()映射到的是动态映射区域。
        2)在使用I/O指令时，可以不使用request_region和request_mem_region，而直接使用outb、ioread等指令。因为request的功能只是告诉内核端口被谁占用了，如再次request，内核会制止。
        3)虽然ＡＲＭ中是采用的ＩＯ内存，但是ＩＯ端口的操作也是一样有效果。这些操作的实现和ＩＯ内存的实现是相同的。




mmap内存映射的实现过程，总的来说可以分为三个阶段：

（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域
1、进程在用户空间调用库函数mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址
3、为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化
4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中

（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系
5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。
6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。
7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。
8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。

 

（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝
注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。
9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。
10、缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。
11、调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。
12、之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。
注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。

    