参看书籍:
<linux设备驱动程序>　第9,15章
<linux设备驱动开发——基于最新的linux 4.0内核＞　 第11章
<深入理解linux内核>　第16章

主要内容：
１.ＩＯ端口与ＩＯ内存的区别
    设备通常会提供一组寄存器来控制设备。若这些寄存器位于ＩＯ空间(独立编址)，则称其为ＩＯ端口，若位于内存空间(统一编址)，则称其为ＩＯ内存。s3c24x0处理器是使用I/O内存。
    注意：
        １)操作内存中的ＩＯ寄存器与内存操作有少许差异为：IO寄存器有边际效应，而内存没有;
        2)边际效应(side effect )：访问I/O寄存器时，不仅仅会像访问普通内存一样影响存储单元的值，更重要的是它可能改变CPU的I/O端口电平、输出时序或CPU对I/O端口电平的反应等等，从而实现CPU的控制功能。CPU在电路中的意义就是实现其side effect 。
        3)导致问题：为了提高内存的访问速度，编译器会对程序进行优化，同时使用高速缓存保存数值和重新编排读/写指令顺序。但对I/O 寄存器操作来说，这些优化可能造成致命错误。
        4)解决方法：关闭硬件缓存，设置内存屏障(barrier(),mb());　
２.访问ＩＯ端口
    驱动程序访问：分配ＩＯ端口(request_region)——>操作ＩＯ端口(8bit inb,outb;16bit inw,outw;32bit inl,outl;一串字节 insb,outsb;一串字 insw,outsw;一串字 insl,outsl;)——>归还ＩＯ端口(release_region());
    用户空间访问:编译时需要带－Ｏ选项——>在root权限下，运行ioperm/iopl或者通过dev/port来获得端口的操作权限——>使用上述操作ＩＯ端口函数。
    将ＩO端口映射为ＩＯ内存：ioport_map
    注意：
        1)对串的进行操作时，要注意字节序的问题。
        2)为了匹配低速外设的速度，有时若 I/O 指令后面还紧跟着另一个类似的I/O指令，就必须在 I/O 指令后面插入一个小延时。在这种情况下，可以使用暂停式的I/O函数代替通常的I/O函数，它们的名字以 _p 结尾。
        3)端口映射到内存，支持所有函数。串操作 用C语言实现。端口是 unsigned int 类型。

３.访问ＩＯ内存
    驱动程序访问：分配ＩＯ内存(request_mem_region)——>地址映射(ioremap())——>操作ＩＯ内存(8,16,32bit的读写分别为readb,writeb,readw,writew,readl,writel;此外,如果有_relaxed,则代表没有内存屏障,此外，还有相应的接口ioread8/iowrite8等)——>解除映射(iounmap())——>归还ＩＯ端口(release_mem_region())
    用户空间访问：在用户空间访问设备地址是通过驱动中的mmap建立用户空间与设备地址空间的映射。
    如果该驱动没有提供该方法则无法访问。通过系统调用mmap()会给进程分配虚拟地址(得到vma)，在mmap的实现中会根据文件标识符会调用驱动对应的mmap()方法(在哪里实现的？)，驱动中实现mmap方法有两种：
        1)在驱动的mmap方法中调用remap_pfn_range分配页框，并且建立页表项(实现物理地址和虚拟地址的对应)——>并为VAM添加相应操作——>当发生缺页异常(该物理内存的数据没有写入内存中)——>首先找到缺页的虚拟地址所在VMA，并分析页目录项，页表——>发起写时复制，并将数据读入内存中       
        ２)在mmap方法中没有分配页框，但实现了线性区VMA的接口函数falut()/nopage()——>当发生缺页异常(发生该虚拟地址没有地址)——>首先找到缺页的虚拟地址所在VMA，并分析页目录项，页表——>如果页表对应的物理页不存在，则发起调页请求——>如果该调用为线性调用的文件结构体中存在fault方法（即非匿名映射），则调用该方法建立映射——>将物理地址填到页表中。(如果需要使用函数mremap()对虚拟线性区进行缩小和扩大，则必须要有falut()/nopage()的支持) 
    ＩＯ内存的静态映射：map_desc()
     注意：
        1)ioremap()映射到的是动态映射区域。
        2)在使用I/O指令时，可以不使用request_region和request_mem_region，而直接使用outb、ioread等指令。因为request的功能只是告诉内核端口被谁占用了，如再次request，内核会制止。
        3)虽然ＡＲＭ中是采用的ＩＯ内存，但是ＩＯ端口的操作也是一样有效果。这些操作的实现和ＩＯ内存的实现是相同的。

4.访问文件：
    缓存IO访问：
    直接ＩＯ访问：
    异步ＩＯ访问：
    内存映射：
        mmap内存映射的实现过程，总的来说可以分为三个阶段：(按下面的理解有两个问题，如果驱动中没有通过调用remap_pfn_range调用物理页，在则需要在第三阶段建立物理页，调页请求；同时，如果实现了remap_pfn_range调用物理页，那数据是否已经调用到内存中去了，还是之后要通过写时复制或者什么方法来实现)
        1)进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域
            1、进程在用户空间调用库函数mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
            2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址
            3、为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化
            4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中

        2)调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系
            5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。
            6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。
            7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。
            8、如果通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。值得注意的是，这个映射也可以不在这里实现，当触发缺页异常时，如果没有建立映射，异常处理函数也会分配页框，并且建立映射。

        3)进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝
            注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。
            9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前没有建立地址映射或者建立了地址映射，但真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。
            10、缺页异常进行一系列判断，确定无非法操作后，如果是没有建立地址映射，内核发起请求调页过程；如果建立了地址映射，内核将发起写时复制过程。
            11-1、调页请求:分为线性(通过有无文件结构体或者nopage函数判断是否是匿名/文件)映射、非线性映射、swap情况下映射，并根据情况将所缺的页从磁盘装入到主存中。
            12-2、写时复制：将所缺的页从磁盘装入到主存中
            12、之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。
            注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。  
    同步访问文件：
    
5.直接内存访问(DMA)：






实验过程：
    查看/home/guqinglei/Writing_code/vexpress_cortex-a9/ldd3中的实验