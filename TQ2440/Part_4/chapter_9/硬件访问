参看书籍:
<Linux设备驱动开发详解——基于ＬINUX 4.0 内核>
<Linux设备驱动程序>
<深入理解linux内核>


主要内容：
１.ＩＯ端口与ＩＯ内存的区别
    设备通常会提供一组寄存器来控制设备。若这些寄存器位于ＩＯ空间，则称其为ＩＯ端口，若位于内存空间，则称其为ＩＯ内存。
    值得注意的是：
        １）操作内存中的ＩＯ寄存器与内存操作有少许差异为：IO寄存器有边际效应，而内存没有;
        ２）边际效应：编译器优化或者高速缓存可能使程序发生指令的重新排序;
        ３）解决方法：设置内存屏障(barrier(),mb());　
２.访问ＩＯ端口
    驱动程序访问：分配ＩＯ端口(request_region)——>操作ＩＯ端口(8bit inb,outb;16bit inw,outw;32bit inl,outl;一串字节 insb,outsb;一串字 insw,outsw;一串字 insl,outsl;)——>归还ＩＯ端口(release_region());
    注意：对串的进行操作时，要注意字节序的问题。
    用户空间访问:编译时需要带－Ｏ选项——>在root权限下，运行ioperm/iopl或者通过dev/port来获得端口的操作权限——>使用上述操作ＩＯ端口函数。
３.访问ＩＯ内存
    驱动程序访问：分配ＩＯ内存(request_mem_region)——>地址映射(ioremap())——>操作ＩＯ内存(8,16,32bit的读写分别为readb,writeb,readw,writew,readl,writel;此外,如果有_relaxed,则代表有内存屏障)——>解除映射(ioremap())——>归还ＩＯ端口(release_mem_region())
    注意的是：iounmap()映射到的是动态映射区域。  　

    用户空间访问：在用户空间访问设备地址是通过驱动中的mmap或者方法进行访问，如果该驱动没有提供该方法则无法访问。
        mmap()，
        falut()/nopage()映射　
    ＩＯ内存的静态映射：
    将ＩO端口映射为ＩＯ内存：
    直接ＩＯ访问：
    直接内存访问(DMA)：