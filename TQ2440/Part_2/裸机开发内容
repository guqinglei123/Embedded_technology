参看书籍:
《嵌入式LINUX开发宝典——基于ARM cortex-A8 处理器》
《嵌入式LINUX应用开发手册》
文档——第3章 ARM启动代码设计
文档——Uboot启动流程分析
1）.基本工具的使用
    1.学习lds文件的书写
    2.学习arm-linux-gcc（预处理，编译，汇编，链接）/ld/readelf/objcopy/objdump的使用——gcc编译的时候记得要有-g才可以用调试
    3.学习makefile的书写（先是gcc 生成.o文件，然后将起使用ld进行链接生成elf文件，在将elf文件转换为bin文件）
    4.反汇编分析
2）~3）.arm芯片的学习
4）.启动流程的分析
5）.核心初始化
    1.ARM汇编指令
        1）算术和逻辑指令  mov，mvn,sub,and,orr,bic 
        2）比较指令 cmp，tst
        3）跳转类指令 b，bl，
        4）移位指令 lsl，ror
        5）程序状态字访问指令 msr，mrs，mcr，mrc
        6）存储器访问指令  ldr，str
    2.设置异常向量（系统运行模式与异常类型。跳转指令的区别，ARM寻址方式）
    3.CPU进入SVC模式(RAM的寄存器介绍，mrs，msr命令)
    4.关闭开门狗(配置控制寄存器，bic，orr指令的使用)
    5.屏蔽中断
    6.关闭MMU（计算机的储存体系，MMU的作用，CP15，mcr，mrc命令）
6）.点亮led
    1.通过寄存器控制LED(汇编与C)——了解芯片的主要GPIo寄存器及使用方法
    2.IO口的输入三种状态（输入浮空/输入下拉/输入上拉），输出的两种状态（开漏输出/推挽输出），第二功能
    3.通过总线方式控制LED——如何确定GPIO的地址以及相应操作。
    4.ARM中的字，存储器格式，非对齐访问
7).时钟初始化
    1.时钟体系——四个问题（晶振频率，有几个PLL，PLL产生了几个时钟，时钟分别做什么）
    2.时钟的配置——（配置lock time，设置分频数，是否设置CPU为异步模式，设置FCLK）
    3.配置PWM定时器，系统定时器，实时时钟（RTC），看门狗(watchdog)——（未学）
8).内存初始化
    1.存储器基础知识（内存（SRAM，DRAM（SDRAM，DDR，DDR2）），外存（ROM（PROM，EPROM，E2PROM），flash（nor-flash，nand flash）））
    2.内存结构及计算方法（表结构，L-Bank，寻址信息，4×单元格数量×单元格容量）
    3.ARM芯片的地址空间（2440为256M+1G+没有使用一共4G）
    4.存储控制器寄存器的初始化（配置BWSCON等13个寄存器）——如何快速的实现多个寄存器的控制
        1）设置位宽（BWSCON）
        2）设置BANK接的储存芯片类型以及列地址数（BANKCON6~7，0~5选择默认）以及相应的时间周期
        3）设置刷新频率（REFRESH）
        4）设置BANKD起始地址（BANKSIZE）
        4）配置CAS等待时间
9）.代码复制到RAM中
    1.访问步骤（SDRAM时序）
        1）选择片选信号,选中芯片
        2）根据两个地址信号选中L-BANK
        3）进行行与列寻址
        4）数据传输
    2.从SRAM（stepping stone）中4字节4字节的复制到SDRAM中链接地址上中，而不是直接从nandflash中直接复制。
    3.链接地址（0x30008000）与内存地址/下载地址（0x30000000）。
    ４．为什么要从stepping stone跳转到ＳＲＡＭ的，并且如何实现。
        当运行地址和链接地址不相等，那么执行到一些指令的时候将会出现程序跑飞的情况。uboot刚刚开始下载在nandflash中
        （为什么地址是0x30000000？），然后启动后将Ｎandflas中前４Ｋ自动stepping stone(地址是0x00000000)中(这
        时候的链接地址不等于运行地址)，只有通过之后将stepping stone中４ｋ代码复制0x3000８000这个地址，这时候链接
        地址才等于运行地址。实现方法是通过ldr实现的。
10）.设置栈与bss段
    1.uboot的内存分布
    2.栈的作用以及栈指针的生长方式(满栈，降栈，堆栈指针（R13，sp），栈帧（R11寄存器，也就是FP），
    栈的地址应该设置多少（这里设置为SDRAM的顶部为0x30000000+64M=0x34000000）)。
    3.栈的作用（调用函数栈做了那些工作。存局部变量，传递大于4个的参数，保存寄存器的值）
    4.Uboot的内存发布以及bss段的作用
    (代码：代码段；初始化全局：数据段；未初始化的全局：BSS；初始化的局部：栈；动态分配区：堆)；
    程序运行时内存分布:
    （bss段：存放没有被初始化或初始化为0的全局变量，只占用程序运行时的内存空间，而不占用程序文件的储存空间；
    data段：初始化过的全局变量数据段，该段用来保存初始化了的非0的全局变量，data段中的变量既占程序运行时的
    内存空间，也占程序文件的储存空间；rodata段：用于存放常量数据；text段：用来存放程序的代码（如函数）和
    部分整数常量（立即数）；stack段：用来保存临时变量和函数参数；heap段：动态内存申请）
    5.如何跳转到mian函数
    （bl跳转和ldr的区别。bl的地址与链接地址有关系，与运行位置无关，而且只能32MB左右寻址；
    ldr的地址与运行地址有关系，与运行位置有关）
    6.volatile的作用
    易变的，不可优化的，顺序性
11).承上启下
12).MMU的使用
13).中断与按键
14).硬盘的使用
15).串口的使用
16).DMA的使用
17).LCD的使用
18).触摸屏的使用
19).网卡的使用
20).移值bootm命令
21).IIC
21).SPI
22）